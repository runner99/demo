Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，也就是内存划分。栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。
程序计数器，是线程私有的，生命周期和线程一致，里面存储的是当前线程执行的字节码地址 ，当前方法是java方法则是 jvm字节码地址，是native方法则是未定义对象 ，他是程序流程控制的指示器，参与程序的分支、循环、跳转、异常处理、线程恢复
虚拟机栈 ，是线程私有的，生命周期和线程一致，里面存储的是栈帧，每一个栈帧对应一个java方法，每有一个新的java方法被执行，虚拟机栈就会入一个栈帧，当前方法执行完后，虚拟机栈就会抛出顶部栈帧。虚拟机栈主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回
                存放局部变量【存储方法参数和定义在方法体内的局部变量，局部变量表中的变量只在当前方法调用中有效，局部变量表所需要的容量大小是编译期确定下来的】
                操作数栈【在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，所需的最大深度在编译期就定义好了】，
                动态连接【每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接】，
                返回地址 【方法调用者的PC寄存器地址】
本地方法栈  管理本地方法的调用
堆内存   存放对象实例，几乎所有的对象实例以及数据都在这里分配内存 。
            TLAB,JVM为每一个线程分配了私有缓存区域，这个区域在伊甸园区。当创建一个实例对象时，优先使用TLAB创建
方法区 ： 存放类信息，静态变量，运行时常量池

类的加载机制：
加载： 1】 通过类的全限定名称来获取定义这个类的二进制文件流   2】将这个类字节流代表的静态数据结构转为方法区的运行时数据结构 3】 创建java.lang.class 对象，作为访问类变量的入口
验证： 目的是保证class文件中的字节流包含的信息不会危害到虚拟机自身的安全 ，主要的验证手段有 1 文件格式验证，2元数据验证，3字节码验证，4符号引用验证
准备： 为类的静态变量分配内存 并将变量设置为默认值
解析： 将符号引用转为直接引用
初始化：调用cinit函数，给类变量赋值
触发类加载的时间： new关键字实例化对象 ；初始化子类；引用
类加载器：负责将.class文件载入jvm 内存,系统的加载器分为3类 【启动类，扩展类，应用类】
双亲委派机制 ，tomcat的类加载机制【看缓存中又没有加载过这个类，如果没有，尝试让系统类加载器加载，防止一些基础类被覆写，如果没加载成功,将加载任务交给web自定义的类加载器尝试加载，还未加载成功，交给通用类加载器加载】

OOM的产生原因：
1. 内存自身不足，再分配对象较多的时候就会报错
2. 程序中存在内存泄漏

垃圾回收：
      JVM规范并没有规定垃圾回收器是如何实现的，但是要求保证不能把正在使用的对象回收掉
      确定哪些对象是能被回收的： 可达性分析法 。首先确定一组GC Roots ，有活跃线程的相关引用，类的静态变量引用，JNI引用 三部分构成  ，之后根据GCroots 从上而下的收缩和回溯 ，得到一组引用链，不在引用链上的对象是为不可达，可以回收。
在引用链上的对象根据其引用强度的不同做不同处理 。引用强度有强引用，软引用，弱引用，虚引用 。强引用是强度最高的引用关系，即使在内存不足的情况下jvm也不会回收该对象 ，软引用是可有可无的对象，在内存不足的时候，就会将软引用的对象回收
弱引用对象只要触发了GC，就会被回收，虚引用总是返回null。它用于追踪一个对象的回收过程。
     垃圾回收算法： 标记【标记所有可达的对象】，清除 【直接将不可达对象删除，但是会留下很多碎片空间】，复制【开辟一块等大的内存，将可达的对象依序放到内存，会比较浪费内存资源】 真理【删除不可达对象，同事将可达对象移动，使得他们紧紧的挨在一起，程序比较耗时】
      分代： 【弱代引用问题，大部分对象存活时间短，其他对象存活时间长】 年轻代 和老年代 1：2   。年轻代里的对象存活时间非常短，来年代里的对象存活时间较长 。两代采取的 垃圾回收算法就不一样 。年轻代采用复制算法，因为剩余的存活不多，采用复制算法非常高效，由于复制算法
需要浪费一定的内存空间，所以年轻代又划分为了1个伊甸园区和2个幸存者区。他们的比例占比默认是8：1：1 ,两块幸存者区中有一块是存放可达对象的，另一块是用于复制的。另外，伊甸园区中还有一个TLAB的缓冲区，是JVM为每一个线程开辟的缓冲区域，用于加速对象分配。 。老年代则
采取的是标记-清除算法或者标记整理算法 。因为老年代中存活的对象较多并且老年代的空间比较大，使用复制算法耗内存也耗时间。
      当年轻代的伊甸园区分配满了的时候，会触发年轻代的GC. 如果是第一次GC ,就会将伊甸园区中的存活对象移动到幸存者区from区，然后清空eden ,不是第一次GC 的话， 将from区和伊甸园区中的对象移动到to区 ，最后清空from区和eden区。
      年轻代发生GC的时候，为了避免扫描整个老年代造成资源浪费，引入了卡表概念。老年代被分为很多个卡页，当老年代的对象引用了年轻代的对象之后，他所在的卡页对应的卡表的位置就会被设置成dirty，这样之后发生年轻代GC之后，就不用扫描整个老年代了，他会从卡表中古获取脏页，然后从这些脏页里面扫描GCRoots 
GC回收的时候还涉及到对象的跨代转移，就是年轻代中的对象转移到老年代中。对象进入老年代的途径：
1.提升，每经过一次年轻代的GC ，存活的对象的年龄就会+1.当年龄达到阈值时就会将这个对象转移到老年代，阈值是有一个参数控制的最大值是15
2.分配担保,每一次GC后存活的对象不一定都小于10%,哪些超出来的对象就会被放到老年代
3.大对象直接在老年代中创建，有一个阈值表示超过这个阈值的对象会直接在老年代创建，但是默认是0，表示的是优先在伊甸园区创建
4.动态对象年龄判定，在幸存者区中，当同一个年龄的对象的大小超过幸存者区的一半时，大于或等于该年龄的对象会被转移到老年代
STW： 在垃圾回收的时候，需要暂停用户的一切线程，在这段时间内，是不能new 对象的，只能进行等待，表现在JVM上就是短暂的卡顿，卡顿时啥也干不了。
垃圾回收器： 年轻代 和老年代 
 CMS垃圾回收器老年代的回收过程：
1.初始标识，它会将GCRoots 和 年轻代中直接指向GCRoots的对象标记，这个阶段是需要阻塞其他用户线程的
2.并发标识，该阶段不会阻塞其他用户线程，他会基于GCRoots将所有可达的对象标识
3.并发预清理，上一阶段由于是和用户线程并发执行的，他标记的对象状态会被用户线程改动，需要将卡表里面的dirty页中的对象进行重新标识 
4.可中断的并发预处理，并发预处理阶段也会长生对象标记不准确的现象，但是这个是无法避免的，只能尽可能的追赶引用变化的速度，当年轻代中的数据比较少且满足一定条件后，就会中断与清理过程
5.最终标记，这个过程需要阻塞用户线程，它会将可达的对象做标记
6.并发清除，清楚不可达的数据
7.并大充值，将CMS内部的数据结构重置，等待下一次CMS垃圾回收




