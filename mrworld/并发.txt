1】 创建执行线程的两种方法 
2】线程的特征、分类、状态 主线程，优先级，共享内存，守护
3】callable接口与runable接口
4】 synchornized 对象 。 synchornized 应用在类的方法上和代码块上。在普通方法上表示对this加锁，在静态方法上表示对类加锁。在代码块上对对象加锁。
锁的本质也是一个对象，他内部有一个标志位表示该对象是否被占用，如果被占用，内部还记录着被哪个线程占用。除此外，还维护者ThreadList,存储着被该锁阻塞和等待该所的线程。 锁的实现借助于 对象头里面的mark words 
synchorized底层由monitor实现的，在尝试进入synchornized标记的方法前需要调用moniterenter成为monitor的owner.
5】wait 和notify 通常在线程成功获取锁之后由于其他条件不满足时调用wait方法。 调用wait方法会使线程会将cpu和锁资源全部释放， 锁对象的waitlist里面记录当前线程。调用notify方法或者notifyAll方法会将waitlist中的线程唤醒，被唤醒的进程会参与锁的竞争。
6】InterruptException 和 interruput()方法 ，interrupted() 和 isinterrupted()的区别和联系  。
7】如何关闭线程。
8】并行和并发 ：并行是多个任务在同一时刻执行。并发是多个任务在一个时刻发生，不一定是同一时刻执行
9】同步,一种协调多个任务访问共享资源的机制,分为控制同步和数据访问同步. 信号量同步机制和 监视器
10】 不可变对象,在Java中体现为被final关键字修饰的对象,他一经初始化就不能被修改,是线程安全的
11】 原子操作和原子变量. 指的是操作只有成功和失败两种状态,没有正在执行的状态的操作.原子变量是指 值得读取和设置都是由原子操作完成的变量
12】数据竞争,多个任务在临界段之外对共享资源进行写入操作,以至于程序的最终结果和预期的不一致
13】死锁.四个条件 互斥的,线程是占有并等待,不可剥夺的,循环等待
14】活锁.资源不足,优先级反转
15】CPU 和内存的架构关系
16】内存可见性: JVM的抽象内存模型\重排序
17】内存屏障:一条指令,对编译器和CPU的指令重排做出限制,内存屏障后面的指令不能移动到内存屏障前. 在多线程环境下,多个线程同时对一个变量进行读取或者写入,如果不对重排序做限制,执行结果和重排序后的指令顺序有关了
18】as-if-serial
19】happen-before ,如果A happen-before B,那么A比B先执行的话,B一定能看见A的执行结果. 单线程.voliate的写如何读取,synchornized 锁的释放和竞争
20】volatile 关键字  64位数的写入,DCL 问题
21】final 构造方法溢出问题以及其happen-before语义
   BlockingQueue 系列  ArrayBlockingQueue
22】CopyOnWrite, 读的时候不加锁 ,异空间换时间 CopyOnWriteArrayList
23】ConcurrentLinkedQueue 入队和出队 head和tail的表示
24】ConcurrentHashMap 数据结构,初始化过程[什么时候初始化],put过程,get过程,扩容过程,红黑树和链表相互转变
并发级别,sizectl  数组的长度 [有初始长度经过计算得到].
多线程避免重复初始化,初始化table的时机 1.将sizectl设置成-1 
25】Semaphore 信标 ,用semphore 表示资源的数量 semphore.acquire() ,semphore.release(). 资源有限,线程较多
26】countDownLatch latch.countdown() ,latch.await() . 等待线程执行完毕做其他操作
27】semphore 和 countdownlatch 都基于AQS 实现的
28】Phaser 动态调整线程数 ,多层次 phaser,state变量解析
29】Atomic 类 AtomicInteger   CAS  乐观锁和悲观锁 。getAndIncrement()
30】自旋和阻塞  。在线程获取不到锁后，线程的两种处理方式。单核CPU阻塞，多线程则选择 自旋，因为没有线程切换开销
31】为什么还需要Boolean ，cas只支持 long，int,引用三种，double和bool的cas是如何实现的
32】CAS的ABA问题，版本号解决了ABA问题  。AtomicMarkableReference 引入版本概念。Integer ,long的CAS 不能同时比较两个变量，需要将版本和值封装成一个pair然后进行CAS
33】互斥锁，可重入锁，公平锁和非公平锁底层实现原理 ReentranLock ，FairSync,NoFairSync。实现具有阻塞和唤醒功能的锁需要哪些条件？（AQS 框架的四要素） 1.state 变量 cas ;2.记录是哪个线程持有 3. 维护ThreadList ，存储着被阻塞的线程 4.支持对线程做唤醒和阻塞操作
34】 









