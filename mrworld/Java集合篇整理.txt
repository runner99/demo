List : 
Set :
Queue :
Map :
Redis :
集合 ：

HashMap ：应用 
数组+链表+红黑树的数据结构 
为啥用数组来实现Map ？
map存的是key-value 即entry对象 ， 
数组存放一个东西，得到下标
下表怎么来 ，通过key做hash运算，算出一个数字hashCode。 hashCode取余得到数组下标。
链表的出现会导致哈希冲突，entry里面有next指针
1.7的  put【key-value生成entry对象，包含next ，取余算下标。 （基于链表的插入时，插入头部的效率比插入尾部的效率高），table[index] = new Entry(k,v,table[index】)】，
如果table是空，初始化table，数组的容量
如果key 是null ，触发分支 【hashMap的key是可以为null的】，凡在index =0 所在的位置
通过key算出hashCode ，key对象重写hash方法，留下问题 1，重写的hash方法散列性比较差的话会导致map中的链表比较大，不方便get， 问题二为什么拿到hashCode后还需要做由于或者异或运算 ，让高位参与运算，使得hash比较均匀，减少hash冲突。取余的编程  与操作 hash值和（length-1），取余操作慢于与操作
添加元素，添加到头部位置，然后链表下移，创建成功后，size+1 ，所以size（） 非常快速。put有返回值，两对象hash值不等，两对象也不等 equals先算 的话可能会。。
get【算出数组下标，找出链表，遍历链表】
初始容量，扩展因子 【默认初始容量 16，加载因子 0.75】Thredhold 扩容阈值，size 当前个数，table[]
初始化数组： 找到大于指定size的 2的幂次方数，然后在用这个数进行初始化    ， 
扩容： 当前size大于了阈值并且放置的位置上有链表就扩容。
如果没有扩容，某些链表的元素越来越多，查询效率越低。是针对数组进行的扩容，开辟新数组，转移元素到新数组


1.8 加了红黑树，极端情况下链表还是比较长，相比于其他数据结构，红黑树的插入和查询的效率都比较好，是均衡的。
多了一个阈值，用于树化，链表的长度大于8个时，将链表变为红黑树，当红黑树只有6个时，变为链表，为了防止频繁的插入或者删除
hash算法简化了。
数组是空的 进行初始化和扩容
插入的位置是尾部，因为树化
插入后若 阈值下雨size ，开始扩容
超过8后也不一定树化，因为会扩容，size<64 就行

1.底层结构
2.扩容时机过程

3.插值过程 : 初始化table, 算出hashCode和数组index,如果下标出没有节点直接放置，如果没有，遍历链表找出旧值，找到旧值就覆盖，没找到用头插法插入
4.获取值过程
5.并发的坑

红黑树  结构和定义，如何平衡，构建时间复杂度，增上改查时间复杂度创建
没有平衡性要求，自平衡的二叉查找树， 插入或删除的时候调整的频率没有AVL多，平衡性没有AVL好。插入或删除不频繁，搜索频繁用AVL，插入删除很频繁用红黑树
一个节点不是红色就是黑色；根节点是黑色的；红色的节点不能有红色的节点；空指针设为叶子节点；从任何节点到最下面的节点的路径都有相同的黑色节点
高度： 2log2(n+1)
hash算法是最高效的查询算法
二分查找【有序数列】

concurrentHashMap： 解决hashMap的并发问题。 1.7
有双层数组，segment数组，segmen类继承了ReentrantLock 类，里面有HashEntry<>数组
put ：依据key算出segment的下表，调用当前segment数组中对应的对象加锁，调用这个对象的put，将K_V对象放入，释放锁。tryLock（） 和lock()的区别：lock是阻塞加锁，tryLock()是非阻塞加锁。while(!tryLock){} 占用CPU，优点是
构造方法：加载因子，数组的初始化大小【segment数组内部的entry数组长度的总和】，concurrencyLevel【segment的数组大小，并发级别，当前这个map最多支持多少个线程同时操作，最大是2的16次方。】；
       步骤：1.生成一个segment数组。数组长度是大于等于level的2的幂次方数。2。向segemnets[0] 放置一个segment对象，【生成一个entry数组，该数组的大小是大于等于（容量/segment数组长度）的2的幂次方数，该值最小是2】 UNSAFE.putOrder()
hash与操作算出下标的前提条件是长度是2的幂次方
1.8 
结构是： 数组+链表+红黑树       node（key,value不能为空) 

hashTable : 性能很低 put 方法的前面，有一个synchorized 关键字，保证现成的安全 ，表示这个对象本身在put的时候就会被锁住，加锁力度过大。整个对象都被锁住了，每一次插入都要等待锁，插入效率差特别是并发下两个不同下标的值，没法支持同时插入多个值。

mysql 内部结构和各组件的关系


1.首先是确定交互的流程。参照游戏的同步方式，公司最后定下来的流程。前置条件，有一个多人联机界面，界面上有创建房间和加入房间按钮。 流程是：
1.用户先到多人联机界面创建房间 ，创建的时候指定房间名称，房间描述，房间密码，房主，到期时间，房间人数，开始时所在的世界等信息。
2.创建成功后会显示一个房间的邀请码，每一个房间的邀请码都不一致。
3.其他用户到多人联机界面中搜索房间，并输入密码进入房间。也可以直接点击加入房间，输入邀请码进入房间。
4.房主点击开始游玩按钮，进入加载阶段。用户会下载初始世界的内容，用户只有下载好初始世界内容后才能和其它用户进行交互。 
5 房主点击开始游玩后就进入世界开始操作物体和触发物体上的事件 。同时服务器记录房主操作，并定期存储状态
6.其他用户下载好世界后，先追上房主的操作，然后跟随房主游玩世界
7.房主退出房间或者房间使用时间到期。清除房间内用户并销毁房间。
2.确定交互的方式和分工
交互分为指令同步+状态校验 。交互的时候，房主的操作指令会实时的上报云端，同时会定期将房主的状态传输到云端。其他用户定期比对自身的状态和房主的状态。若状态不对，则调整状态。状态调整好之后将房主的操作复现即可。
服务端负责处理房间的创建，销毁，用户加入房间和退出房间 ，消息的存储，转发，状态的存储
服务端部分分为两个服务，消息模块和房间模块。
消息模块是基于SpringBoot ,netty  ，redis实现的 。它的功能有
指令处理【一个指令到达后，首先从格式，权限，属性值等方面做校验 ，然后分配为指令分配ID ,最后根据指令的属性，确定该指令需要发送给哪些用户，将指令放入房间操作指令级队列和需要发送的用户的消息队列中】
指令存储【服务器开辟一个子线程，定期的将指令从房间的消息队列中取出，并写入数据库】
指令转发【房间开启同步的10帧约2s后，开启一个定时任务,每隔一帧，就从取出用户消息队列里的一帧消息将消息发送给用户所在的客户端。2s 后开启的目的是为了保证游客和导游之间的延迟稳定】。
 对用户退出房间，用户掉线，房间销毁等操作做支持。
状态存储【定期接收房主的状态】
redis 的作用：1 .存储临时消息 ，因为处理消息过程中需要将消息持久化到本地 。如果直接写入mysql，写入速度太慢了，消息处理效率不高。如果用消息队列做异步，强行增加了系统的复杂性。
                     2 .存储房间里的用户列表，用户待接收消息的列表 ，用户的操作指令列表 
                     3 .实现并发计数器，每有一消息到达房间时，需要为消息分配一个消息ID 。如果一个时刻内某一个房间内有很多消息到达服务端，要确保每一个消息都有唯一的消息ID。
架构是 : redis 集群 和文件做存储层。用netty 处理请求 。 
首先是一个NIO框架 。采用多线程Reactor 模式
使用docker制作镜像。

灵境云服务：


素材服务：

机器授权：

行业服务器的部署：给企业部署的服务器
公司的注册，服务器的注册，配置的动态处理




redis 用于临时存储消息，用户-房间关系 ， 
            netty
8. 服务端部分的功能：1.处理房间的创建销毁，用户加入房间的功能

2.根据流程划分模块，每部分处理什么内容

租赁服务 4.
灵境云服务










